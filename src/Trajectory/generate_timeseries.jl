using Distributions, LinearAlgebra, Random

export generate

# Define the jump map
function next_state(current_state_index::Int, cT)
    vcT = view(cT, :, current_state_index)
    u = rand(Uniform(0, 1))
    # choose a random uniform variable and decide next state
    # depending on where one lies on the line with respect to the probability 
    # of being found between given probabilities
    for i in eachindex(vcT)
        if u < vcT[i]
            return i
        end
    end

    return i
end

"""
    generate(Q, n; dt=1, initial_condition=rand(1:size(Q)[1]))

Generate a Markov chain of length `n` with transition matrix `Q` and time step `dt`.

# Arguments
- `Q::AbstractMatrix`: The transition matrix or generator of the Markov chain.
- `n::Int`: The length of the Markov chain.
- `dt::Real=1`: The time step of the Markov chain.
- `initial_condition::Int=rand(1:size(Q)[1])`: The initial condition of the Markov chain.

# Keyword Arguments
- `progress::Bool=false`: Whether to show a progress bar.

# Returns
- `Vector{Int}`: A Markov chain of length `n` generated by transition matrix `Q` and time step `dt`.
"""
function generate(matrix, n, dt, initial_condition; progress = false)
    if all(sum(matrix, dims=1) .≈ 1)
        P = matrix
    else
        P = exp(matrix * dt)
    end
    cP = cumsum(P, dims=1)
    markov_chain = zeros(Int, n)
    markov_chain[1] = initial_condition
    progress ? iter = ProgressBar(2:n) : iter = (2:n)
    for i = iter
        markov_chain[i] = next_state(markov_chain[i-1], cP)
    end
    return markov_chain
end

generate(Q, n; dt=1, initial_condition=rand(1:size(Q)[1]), progress = false) = generate(Q, n, dt, initial_condition, progress = progress)

function generate(Q; dt=1, decorrelation_threshold=0.01, initial_condition=rand(1:size(Q)[1]), progress = false)
    n = step_heuristic(Q; dt=1, decorrelation_threshold=decorrelation_threshold)
    return generate(Q, n, dt, initial_condition; progress = progress)
end

"""
    generate(process::ContinuousTimeEmpiricalProcess, n; initial_condition=rand(1:size(process.cumulative_distribution)[1]))

Generate a Markov chain of length `n` with continuous time empirical process `process`.

# Arguments
- `process::ContinuousTimeEmpiricalProcess`: The continuous time empirical process to generate a Markov chain from.
- `n::Int`: Number of jumps to generate. i.e. lower bound to length of markov chain 
- `initial_condition::Int=rand(1:size(process.cumulative_distribution)[1])`: The initial condition of the Markov chain.

# Keyword Arguments
- `progress::Bool=false`: Whether to show a progress bar.

# Returns
- `Vector{Int}`: A Markov chain of generated by a continuous time empirical `process`.
"""
function generate(process::ContinuousTimeEmpiricalProcess, n, initial_condition; progress=false)
    simulated_chain = Int64[]
    push!(simulated_chain, initial_condition)
    progress ? iter = ProgressBar(1:n) : iter = (1:n)
    for i in iter
        current_state = simulated_chain[end]
        htempirical = rand(process.holding_times[current_state])
        for i in 1:htempirical
            push!(simulated_chain, current_state)
        end
        simulated_chain = vcat(simulated_chain...)
        push!(simulated_chain, next_state(current_state, process.cumulative_distribution))
    end
    return simulated_chain
end

function step_heuristic(matrix; dt=1, decorrelation_threshold=0.01)
    if all(sum(matrix, dims=1) .≈ 1)
        P = matrix
    else
        P = exp(matrix * dt)
    end
    ll = eigvals(P)
    real_ll = abs.(real.(ll))

    # edgecase
    if length(real_ll[real_ll.<1-100*eps()]) == 0
        # since not ergodic anyways
        return 2
    end
    slowest = maximum(real_ll[real_ll.<1-100*eps()])
    n = ceil(Int, log(decorrelation_threshold) / log(slowest)) * 10000
    if n < 10^4
        return 10^4
    elseif n > 10^7
        println("warning: step_heuristic is returning a large number of steps.")
        return 10^7
    else
        return n
    end
end
