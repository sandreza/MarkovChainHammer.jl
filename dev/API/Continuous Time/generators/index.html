<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generators · Markov Chain Hammer</title><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">Markov Chain Hammer</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../overview/">Overview</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Discrete Time</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Discrete Time/transfer_operators/">Transfer Operators and Markov Chains</a></li><li><a class="tocitem" href="../../Discrete Time/empirical_transfer_operators/">Data-driven Transfer Operators</a></li><li><a class="tocitem" href="../../Discrete Time/convergence/">Convergence of Transfer Operators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox" checked/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Continuous Time</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Generators</a><ul class="internal"><li><a class="tocitem" href="#Motivation"><span>Motivation</span></a></li><li><a class="tocitem" href="#Using-the-generator-to-contruct-Markov-chains"><span>Using the generator to contruct Markov chains</span></a></li><li><a class="tocitem" href="#Generator-properties"><span>Generator properties</span></a></li></ul></li><li><a class="tocitem" href="../empirical_generator/">Empirical Generator</a></li><li><a class="tocitem" href="../convergence/">Convergence of Generators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Uncertainty Quantification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Uncertainty Quantification/bayesian_empirical_generator/">Bayesian Empirical Generator</a></li><li><a class="tocitem" href="../../Uncertainty Quantification/constructing_prior/">Constructing Prior Distributions</a></li><li><a class="tocitem" href="../../Uncertainty Quantification/sampling/">Sampling from the Bayesian Generator</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Modules/module_overview/">Overview</a></li><li><a class="tocitem" href="../../../Modules/transition_matrix/">TransitionMatrix</a></li><li><a class="tocitem" href="../../../Modules/bayesian_matrix/">BayesianMatrix</a></li><li><a class="tocitem" href="../../../Modules/trajectory/">Trajectory</a></li><li><a class="tocitem" href="../../../Modules/clustering/">Clustering</a></li><li><a class="tocitem" href="../../../Modules/utils/">Utils</a></li></ul></li><li><a class="tocitem" href="../../../function_index/">Function Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li><a class="is-disabled">Continuous Time</a></li><li class="is-active"><a href>Generators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Generators</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/main/docs/src/API/Continuous Time/generators.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="sec:generators"><a class="docs-heading-anchor" href="#sec:generators">Generators</a><a id="sec:generators-1"></a><a class="docs-heading-anchor-permalink" href="#sec:generators" title="Permalink"></a></h1><p>In this section we discuss continuous time markov processes and methods for generating Markov chains from them. They are similar to a discrete time Markov chain, but with a notion of time built into their construction. The idea is to break up the time interval into a sequence of discrete time steps and then construct a discrete time Markov chain from the continuous time Markov process.</p><p>We start by building from the knowledge of the discrete time Markov chain and <a href="../../Discrete Time/transfer_operators/#sec:transfer_operators">transfer operators</a>. As mentioned before the columns of the transfer operator give information on where to go at a subsequent discrete step. But now we want to shift and develop a method that is consistent with the notion of continuous time. Thus the first thing we need to think about is, &quot;How far do we go in time?&quot; and then secondly &quot;How do we make this consistent with the notion of a Markov process?&quot;. </p><h2 id="Motivation"><a class="docs-heading-anchor" href="#Motivation">Motivation</a><a id="Motivation-1"></a><a class="docs-heading-anchor-permalink" href="#Motivation" title="Permalink"></a></h2><p>To motivate the use of a generator, we reexamine the transfer operator</p><pre><code class="language-julia hljs">ℳ = [0.6 0.3; 0.4 0.7]
ℳ</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 0.6  0.3
 0.4  0.7</code></pre><p>The transfer operator determines the probability of state j (here j = 1 or 2) to move to state i in one step. But suppose that we want to know the probability of moving from one state to another in <em>two</em> steps. For example, suppose that we are in state <span>$s_0 = 1$</span> at time 0, then</p><pre><code class="language-julia hljs">s₀ = [1, 0]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Int64}:
 1
 0</code></pre><p>Thus the probability of being in state 1 or state 2 at time 1 is given by matrix multiplication with the state </p><pre><code class="language-julia hljs">s₁ = ℳ * s₀</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 0.6
 0.4</code></pre><p>Now we would find that 60% of our ensembles would be in state 1 after one step and 40% would be in state 2 after one step. But now suppose that we want to figure out how many of our ensembles of states would be in state 1 or state 2 after another step. We simply apply the operator again </p><pre><code class="language-julia hljs">s₂ = ℳ * s₁</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 0.48
 0.52</code></pre><p>To get that 48% of our states ended up in state 1 and 52% of our states ended up in state 2. In total, if we want to just jump straight from our initial state <span>$s_0$</span> to state <span>$s_2$</span>, we can just combine the two steps to get </p><pre><code class="language-julia hljs">ℳ * ℳ * s₀</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 0.48
 0.52</code></pre><p>Thus we see if we want to move one step, we just multiply <span>$s_0$</span> by <span>$ℳ$</span>, if we want to move two steps we multiply <span>$s_0$</span> by, <span>$\mathcal{ℳ}^2$</span>. In general, if we want to move <span>$n$</span>-steps, where <span>$n$</span> is a natural number, then we mulitply by <span>$\mathcal{ℳ}^n$</span>. If we want to move &quot;0&quot; steps, we can use the convention that <span>$\mathcal{ℳ}^0 = \mathbb{I}$</span> where <span>$\mathbb{I}$</span> is the identity matrix.</p><p>But now suppose that we don&#39;t want to compute at just integer steps, we want to compute what &quot;happens in between&quot;, that is to say, raise to a non-integer power. One way to define this for matrices is to make use of the identity</p><p class="math-container">\[\mathcal{M}^n = \exp[n \log(\mathcal{M})]\]</p><p>where the <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/">log and exp functions</a> are the <a href="https://en.wikipedia.org/wiki/Logarithm_of_a_matrix#:~:text=In%20mathematics%2C%20a%20logarithm%20of,function%20of%20the%20matrix%20exponential.">matrix logarithm</a> and <a href="https://en.wikipedia.org/wiki/Matrix_exponential">matrix exponential</a>. For example, the matrix logarithm of <span>$\mathcal{M}$</span> is</p><pre><code class="language-julia hljs">logℳ = log(ℳ)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 -0.687984   0.515988
  0.687984  -0.515988</code></pre><p>and we can check </p><pre><code class="language-julia hljs">exp(logℳ) - ℳ</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
  0.0          0.0
 -1.11022e-16  1.11022e-16</code></pre><p>We see that the mathematical relation holds to <a href="https://en.wikipedia.org/wiki/Machine_epsilon">machine precision</a>.</p><p>We can now check the formula for <span>$n=2$</span></p><pre><code class="language-julia hljs">n = 2
exp(n * log(ℳ)) - ℳ^n</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
  5.55112e-17  -5.55112e-17
 -1.11022e-16   1.11022e-16</code></pre><p>which we again see holds to <a href="https://en.wikipedia.org/wiki/Machine_epsilon">machine precision</a>.</p><p>And finally, we can see what happens if we take non-integer steps</p><pre><code class="language-julia hljs">n = 1.5
ℳhalf = exp(n * log(ℳ))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 0.522467  0.35815
 0.477533  0.64185</code></pre><p>and check to see taking two steps of size 1.5 is the same as taking one step of size 3. We square the matrix corresponding to a step size of 1.5 and check that it is the same as the matrix corresponding to a step size of 3. We take the difference of the two calculations</p><pre><code class="language-julia hljs">ℳhalf^2 - ℳ^3</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
  1.66533e-16  3.33067e-16
 -2.22045e-16  0.0</code></pre><p>to see that the entries are the same to machine precision.</p><p>This brings us to the point we were can finally introduce the generator. Presently, the generator is the matrix logarithm of the transfer operator </p><pre><code class="language-julia hljs">Q = log(ℳ)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 -0.687984   0.515988
  0.687984  -0.515988</code></pre><p>However, we have actually presented the relation backwards! The transfer operator for a time <span>$\tau$</span> in the future is the matrix exponential of the generator Q</p><pre><code class="language-julia hljs">P(τ) = exp(Q * τ)</code></pre><p>In order for the formula to hold for all times <span>$\tau$</span>, stricter requirements must be imposed on the generator. In order for <span>$P(\tau)$</span> to be a probability for all times <span>$\tau$</span>, we require </p><ol><li>The sum of the columns of Q must be zero </li><li>The off diagonal terms of Q must be greater than or equal to zero</li></ol><p>These two requirements can be derived by taking <span>$\tau$</span> to be an infinitely small timestep, which we denote by <span>$dt$</span>, from whence we see </p><p class="math-container">\[P(dt) = \mathbb{I} + Q  dt\]</p><p>where <span>$\mathbb{I}$</span> is the identity matrix. Since the sum of the columns on the left hand side must be one and the sum of the columns of the identity matrix is one, we see that the only option is for the sum of the columns of <span>$Q$</span> to be zero for the identity to hold. The positivity of the off-diagonal terms of the transfer operator implies that the off-diagonal terms of the generator matrix, <span>$Q$</span> must be positive since the formula holds for every entry of the matrix and the identity matrix only modifies the diagonal terms. In fact we can say a bit more. Since probabilities are bounded above by one, we can say that the diagonal terms of the generator matrix must be less than or equal to zero.</p><h2 id="Using-the-generator-to-contruct-Markov-chains"><a class="docs-heading-anchor" href="#Using-the-generator-to-contruct-Markov-chains">Using the generator to contruct Markov chains</a><a id="Using-the-generator-to-contruct-Markov-chains-1"></a><a class="docs-heading-anchor-permalink" href="#Using-the-generator-to-contruct-Markov-chains" title="Permalink"></a></h2><p>We can now use the generator to construct Markov chains. The API in MarkovChainHammer.jl allows for two possibilites. The first is to construct the transfer operator from the generator and then directly use transfer operator as was done in the <a href="../../Discrete Time/transfer_operators/#sec:transfer_operators">Transfer Operators and Markov Chains</a> section. </p><p>For example, defining a generator <span>$Q$</span> and transfer operator <span>$P(\tau)$</span> as </p><pre><code class="language-julia hljs">Q = [-1.0 2.0; 1.0 -2.0]
P(τ) = exp(Q * τ)</code></pre><p>We can define the <span>$\tau = 1$</span>, transfer operator </p><pre><code class="language-julia hljs">P1 = P(1.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 0.683262  0.633475
 0.316738  0.366525</code></pre><p>and then use the generate function as before, </p><pre><code class="language-julia hljs">using MarkovChainHammer.Trajectory: generate
markov_chain = generate(P1, 10)&#39;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1×10 adjoint(::Vector{Int64}) with eltype Int64:
 1  1  1  2  1  1  2  2  1  2</code></pre><p>The second possibility is to use the generator directly. This is done by defining a generator <span>$Q$</span>, choosing a step size <span>$dt$</span>, and then using the <code>generate</code> function with the generator </p><pre><code class="language-julia hljs">n = 10; dt = 1.0;
markov_chain = generate(Q, n; dt = dt)&#39;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1×10 adjoint(::Vector{Int64}) with eltype Int64:
 2  2  1  1  1  1  2  2  2  2</code></pre><p>The above is a chain of length 10, whose time intervals correspond to steps of size <span>$dt = 1.0$</span>. The <span>$dt$</span> term is a keyword argument to the function and associated with a step size. Thus time &quot;time&quot; associated with the chain is, </p><pre><code class="language-julia hljs">time = dt * collect(0:n-1)&#39;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1×10 adjoint(::Vector{Float64}) with eltype Float64:
 0.0  1.0  2.0  3.0  4.0  5.0  6.0  7.0  8.0  9.0</code></pre><p>We can also generate a markov chain sequence of length <span>$n=100$</span> with a step size <span>$dt = 0.1$</span> and then use the <span>$generate$</span> function to generate a chain of length <span>$n$</span> with a step size <span>$dt$</span>. </p><pre><code class="language-julia hljs">n = 100; dt = 0.1;
markov_chain = generate(Q, n; dt = dt)&#39;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1×100 adjoint(::Vector{Int64}) with eltype Int64:
 1  1  1  1  1  1  1  1  1  1  1  1  1  …  1  1  1  1  1  1  1  1  1  1  1  1</code></pre><p>where now the times associated with the process are </p><pre><code class="language-julia hljs">time = dt * collect(0:n-1)&#39;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1×100 adjoint(::Vector{Float64}) with eltype Float64:
 0.0  0.1  0.2  0.3  0.4  0.5  0.6  0.7  …  9.3  9.4  9.5  9.6  9.7  9.8  9.9</code></pre><p>The flexibility of choosing the step size corresponding to a time, and still having the resulting process be <a href="https://en.wikipedia.org/wiki/Markov_property">Markovian</a>, is a powerful feature of the generator. Choosing an arbitrary <span>$dt$</span> but having the statistics remain the same over a physical timescale is what makes the resulting process a &quot;continuous time markov process&quot;.</p><h2 id="Generator-properties"><a class="docs-heading-anchor" href="#Generator-properties">Generator properties</a><a id="Generator-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Generator-properties" title="Permalink"></a></h2><p>In the previous section we introduced the generator, but we did not delve into details about it&#39;s properties or how to interpret the entries of the matrix. This subsection aims to rectify that. We start by interpreting the diagonal entries of the generator matrix and then we will move to interpret the off-diagonal entries. We will soon see that </p><ol><li>The diagonal entries contain information on how much time to spend in a state </li><li>The off-diagonal entries contain information on how to transition between states</li></ol><p>We comment that the generator matrix has units of inverse time whereas the transfer operator is dimensionless. Throughout this section we will use the notation <span>$Q$</span> to denote the generator matrix and <span>$Q_{ij}$</span> to denote the entry in the <span>$i$</span>th row and <span>$j$</span>th column of the matrix.</p><h3 id="Diagonal-entries"><a class="docs-heading-anchor" href="#Diagonal-entries">Diagonal entries</a><a id="Diagonal-entries-1"></a><a class="docs-heading-anchor-permalink" href="#Diagonal-entries" title="Permalink"></a></h3><p>The diagonal entries are used to compute the <a href="https://en.wikipedia.org/wiki/Continuous-time_Markov_chain">holding times</a> associated with states of the markov process. The holding time is an exponentially distributed random variable with mean <span>$-\frac{1}{Q_{ii}}$</span>. The mean is the inverse of the diagonal entry.</p><p>For example, the generator matrix </p><pre><code class="language-julia hljs">Q = [-1 1 1; 1 -2 2; 0 1 -3]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×3 Matrix{Int64}:
 -1   1   1
  1  -2   2
  0   1  -3</code></pre><p>has three states, <span>$1, 2, 3$</span>. The holding time for state <span>$1$</span> is exponentially distributed with mean <span>$-\frac{1}{Q_{11}} = \frac{1}{1} = 1$</span>. The holding time for state <span>$i = 2$</span> is exponentially distributed with mean <span>$-\frac{1}{Q_{22}} = \frac{1}{2}$</span>. The holding time for state <span>$i = 3$</span> is exponentially distributed with mean <span>$-\frac{1}{Q_{33}} = \frac{1}{3}$</span>. Thus the larger the number on the diagonal the less time it spends in that state.</p><p>We can draw a random sample from the holding time distribution using the <code>rand</code> function and the <code>Exponential</code> struct from the <code>Distributions</code> package. For example, to draw a random sample from the holding time distribution for state <span>$1$</span> we can use the following code</p><pre><code class="language- hljs">using Distributions
τ₁ = Exponential(-1 / Q[1,1])
rand(τ₁)</code></pre><p>and if we want to draw another sample from the distribution, we simply call the function again, </p><pre><code class="language- hljs">rand(τ₁)</code></pre><p>and if we want to draw 10 realizations </p><pre><code class="language- hljs">rand(τ₁, 10)&#39;</code></pre><p>and so forth.</p><p>To draw a random sample from the holding time distribution for state <span>$2$</span> we can use the following code</p><pre><code class="language- hljs">τ₂ = Exponential(-1 / Q[2,2])
rand(τ₂)</code></pre><p>and to draw a random sample from the holding time distribution for state <span>$3$</span> we can use the following code</p><pre><code class="language- hljs">τ₃ = Exponential(-1 / Q[3,3])
rand(τ₃)</code></pre><p>Thus we have seen how to remain in a state for a random amount of time. The next step is to move from one state to another.</p><h3 id="Off-diagonal-entries"><a class="docs-heading-anchor" href="#Off-diagonal-entries">Off-diagonal entries</a><a id="Off-diagonal-entries-1"></a><a class="docs-heading-anchor-permalink" href="#Off-diagonal-entries" title="Permalink"></a></h3><p>The diagonal entries told us how long to stay in a state. The off-diagonal entries tell us how to transition between states. For example, using the same <span>$3 \times 3$</span> generator matrix from before</p><pre><code class="language-julia hljs">Q = [-1 1 1; 1 -2 2; 0 1 -3]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×3 Matrix{Int64}:
 -1   1   1
  1  -2   2
  0   1  -3</code></pre><p>we now describe the transition process from one state to another. Suppose that we start in state 2. We see by examning the column </p><pre><code class="language-julia hljs">Q[:,2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
  1
 -2
  1</code></pre><p>That we spend an exponentially distributed random amount of time with mean <span>$1/2$</span> in state 2, then leave the state. Thus the question becomes, &quot;to which state do we go and with what probability?&quot;. There are two possibilities since we have a 3 state system. We can leave to state 1 or state 3. The probability of leaving to state 1 is proportional to the <span>$Q_{12}$</span> entry of the matrix and the probability of leaving to state 3 is proportional to the <span>$Q_{32}$</span> entry. That is to say, we are equally likely to leave to state 1 or state 3. The normalization factor is the sum of the two entries. Thus the probability of leaving to state 1 is <span>$\frac{Q_{12}}{Q_{12} + Q_{32}} = \frac{1}{2}$</span> and the probability of leaving to state 3 is <span>$\frac{Q_{32}}{Q_{12} + Q_{32}} = \frac{1}{2}$</span>. </p><p>A similar story holds for the other states. For example, if we start in state 1, we see by examning the column </p><pre><code class="language-julia hljs">Q[:, 1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 -1
  1
  0</code></pre><p>that we spend an exponentially distributed random amount of time with mean <span>$1$</span> in state 1, then leave the state. Thus the question becomes, &quot;to which state do we go and with what probability?&quot;. There are two possibilities since we have a 3 state system. We can leave to state 2 or state 3. The probability of leaving to state 2 is proportional to the <span>$Q_{21}$</span> entry of the matrix and the probability of leaving to state 3 is proportional to the <span>$Q_{31}$</span> entry. Since <span>$Q_{31} = 0$</span> we are 100% likely to leave to state 2. Thus the probability of leaving to state 2 is <span>$\frac{Q_{21}}{Q_{21} + Q_{31}} = 1$</span> and the probability of leaving to state 3 is <span>$\frac{Q_{31}}{Q_{21} + Q_{31}} = 0$</span>.</p><p>And finally if we start in state 3, we see by examning the column </p><pre><code class="language-julia hljs">Q[:, 3]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
  1
  2
 -3</code></pre><p>that we spend an exponentially distributed random amount of time with mean <span>$1/3$</span> in state 3, then leave the state. Thus the question becomes, &quot;to which state do we go and with what probability?&quot;. There are two possibilities since we have a 3 state system. We can leave to state 1 or state 2. The probability of leaving to state 1 is proportional to the <span>$Q_{13}$</span> entry of the matrix and the probability of leaving to state 2 is proportional to the <span>$Q_{23}$</span> entry. Since <span>$Q_{13} = 1$</span> and <span>$Q_{23} = 2$</span> we are twice as likely to leave to state 2. Thus the probability of leaving to state 1 is <span>$\frac{Q_{13}}{Q_{13} + Q_{23}} = 1/3$</span> and the probability of leaving to state 2 is <span>$\frac{Q_{23}}{Q_{13} + Q_{23}} = 2/3$</span>.</p><h3 id="Final-Comments"><a class="docs-heading-anchor" href="#Final-Comments">Final Comments</a><a id="Final-Comments-1"></a><a class="docs-heading-anchor-permalink" href="#Final-Comments" title="Permalink"></a></h3><p>We have described two methods of simulating a continuous time markov chain. The first method is to construct a transfer operator and then sample at discrete times. The second method is to construct a generator and then sample at continuous times. The two methods are equivalent. The first method is better for working with evenly spaced times, but can suffer from sampling problems if a timestep is chosen &quot;too far in the future&quot; since any short time information is lost. The second method is more true to the continuum nature of a continuous time markov process but suffers from unevenly spaced times. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../Discrete Time/convergence/">« Convergence of Transfer Operators</a><a class="docs-footer-nextpage" href="../empirical_generator/">Empirical Generator »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 7 December 2023 16:58">Thursday 7 December 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
