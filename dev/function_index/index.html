<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function Index · Markov Chain Hammer</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Markov Chain Hammer</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../API/overview/">Overview</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Discrete Time</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../API/Discrete Time/transfer_operators/">Transfer Operators and Markov Chains</a></li><li><a class="tocitem" href="../API/Discrete Time/empirical_transfer_operators/">Data-driven Transfer Operators</a></li><li><a class="tocitem" href="../API/Discrete Time/convergence/">Convergence of Transfer Operators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Continuous Time</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../API/Continuous Time/generators/">Generators</a></li><li><a class="tocitem" href="../API/Continuous Time/empirical_generator/">Empirical Generator</a></li><li><a class="tocitem" href="../API/Continuous Time/convergence/">Convergence of Generators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Uncertainty Quantification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../API/Uncertainty Quantification/bayesian_empirical_generator/">Bayesian Empirical Generator</a></li><li><a class="tocitem" href="../API/Uncertainty Quantification/constructing_prior/">Constructing Prior Distributions</a></li><li><a class="tocitem" href="../API/Uncertainty Quantification/sampling/">Sampling from the Bayesian Generator</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Modules/module_overview/">Overview</a></li><li><a class="tocitem" href="../Modules/transition_matrix/">TransitionMatrix</a></li><li><a class="tocitem" href="../Modules/bayesian_matrix/">BayesianMatrix</a></li><li><a class="tocitem" href="../Modules/trajectory/">Trajectory</a></li><li><a class="tocitem" href="../Modules/clustering/">Clustering</a></li><li><a class="tocitem" href="../Modules/utils/">Utils</a></li></ul></li><li class="is-active"><a class="tocitem" href>Function Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function Index</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function Index</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/main/docs/src/function_index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="sec:function_index"><a class="docs-heading-anchor" href="#sec:function_index">List of functions in MarkovChainHammer</a><a id="sec:function_index-1"></a><a class="docs-heading-anchor-permalink" href="#sec:function_index" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.TransitionMatrix.generator-Tuple{Any}" href="#MarkovChainHammer.TransitionMatrix.generator-Tuple{Any}"><code>MarkovChainHammer.TransitionMatrix.generator</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>generator(markov_chain; dt=1)</code></p><p><strong>Description</strong></p><pre><code class="nohighlight hljs">Calculate the generator matrix from a markov chain.</code></pre><p><strong>Arguments</strong></p><ul><li><code>markov_chain::AbstractVector</code>: A vector of integers representing the state of a markov chain at each time step.</li><li><code>dt::Real</code>: The time step between each state.</li></ul><p><strong>Returns</strong></p><ul><li><code>generator_matrix::Matrix</code>: The generator matrix of the markov chain.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/TransitionMatrix/construct_from_data.jl#L113-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.TransitionMatrix.holding_times-Tuple{Any, Any}" href="#MarkovChainHammer.TransitionMatrix.holding_times-Tuple{Any, Any}"><code>MarkovChainHammer.TransitionMatrix.holding_times</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>holding_times(markov_chain, number_of_states; dt=1)</code></p><p><strong>Description</strong></p><pre><code class="nohighlight hljs">Calculate the holding times of a markov chain.</code></pre><p><strong>Arguments</strong></p><ul><li><code>markov_chain::AbstractVector</code>: A vector of integers representing the state of a markov chain at each time step.</li><li><code>number_of_states::Integer</code>: The number of states in the markov chain.</li><li><code>dt::Real</code>: The time step of the markov chain.</li></ul><p><strong>Returns</strong></p><ul><li><code>holding_times::Vector{Vector{Real}}</code>: A vector of vectors of holding times for each state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/TransitionMatrix/construct_from_data.jl#L54-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.TransitionMatrix.perron_frobenius-Tuple{Any}" href="#MarkovChainHammer.TransitionMatrix.perron_frobenius-Tuple{Any}"><code>MarkovChainHammer.TransitionMatrix.perron_frobenius</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>perron_frobenius(markov_chain; step = 1)</code></p><p><strong>Description</strong></p><pre><code class="nohighlight hljs">Calculate the perron-frobenius matrix from a markov chain.</code></pre><p><strong>Arguments</strong></p><ul><li><code>markov_chain::AbstractVector</code>: A vector of integers representing the state of a markov chain at each time step.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>step::Integer=1</code>: The step size of the constructed operator.</li></ul><p><strong>Returns</strong></p><ul><li><code>perron_frobenius_matrix::Matrix</code>: The perron-frobenius matrix of the markov chain.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/TransitionMatrix/construct_from_data.jl#L37-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.TransitionMatrix.symmetric_generator-Tuple{Any, Any}" href="#MarkovChainHammer.TransitionMatrix.symmetric_generator-Tuple{Any, Any}"><code>MarkovChainHammer.TransitionMatrix.symmetric_generator</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>symmetric_generator(markov_chain, symmetries; dt=1)</code></p><p><strong>Description</strong></p><pre><code class="nohighlight hljs">Calculate the generator matrix from a markov chain with symmetries.</code></pre><p><strong>Arguments</strong></p><ul><li><code>markov_chain::AbstractVector</code>: A vector of integers representing the state of a markov chain at each time step.</li><li><code>symmetries::AbstractVector</code>: A vector of functions that are symmetries of the markov chain.</li><li><code>dt::Real</code>: The time step between each state.</li></ul><p><strong>Returns</strong></p><ul><li><code>generator_matrix::Matrix</code>: The generator matrix of the markov chain.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/TransitionMatrix/construct_from_data.jl#L147-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.TransitionMatrix.symmetric_perron_frobenius-Tuple{Any, Any}" href="#MarkovChainHammer.TransitionMatrix.symmetric_perron_frobenius-Tuple{Any, Any}"><code>MarkovChainHammer.TransitionMatrix.symmetric_perron_frobenius</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>symmetric_perron_frobenius(markov_chain, symmetries)</code></p><p><strong>Description</strong></p><pre><code class="nohighlight hljs">Calculate the perron-frobenius matrix from a markov chain with symmetries.</code></pre><p><strong>Arguments</strong></p><ul><li><code>markov_chain::AbstractVector</code>: A vector of integers representing the state of a markov chain at each time step.</li><li><code>symmetries::AbstractVector</code>: A vector of functions that are symmetries of the markov chain.</li></ul><p><strong>Returns</strong></p><ul><li><code>perron_frobenius_matrix::Matrix</code>: The perron-frobenius matrix of the markov chain.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/TransitionMatrix/construct_from_data.jl#L172-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.BayesianMatrix.BayesianGenerator-Tuple{Any, GeneratorParameterDistributions}" href="#MarkovChainHammer.BayesianMatrix.BayesianGenerator-Tuple{Any, GeneratorParameterDistributions}"><code>MarkovChainHammer.BayesianMatrix.BayesianGenerator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BayesianGenerator(data, prior::GeneratorParameterDistributions; dt=1)</code></pre><p>Construct a BayesianGenerator object from data and a prior distribution.</p><p><strong>Arguments</strong></p><ul><li><code>data::Vector{Int}</code>: The data to construct the BayesianGenerator object from.</li><li><code>prior::GeneratorParameterDistributions</code>: The prior distribution for the BayesianGenerator object.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dt::Number=1</code>: The time step between each data point.</li></ul><p><strong>Returns</strong></p><ul><li><code>BayesianGenerator</code>: A BayesianGenerator object constructed from the data and the prior distribution. Contains the posterior distributions for the rates and exit probabilities, as well as the predictive distributions for the holding times and exit counts.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/BayesianMatrix/constructors.jl#L97-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.BayesianMatrix.BayesianGenerator-Tuple{NamedTuple}" href="#MarkovChainHammer.BayesianMatrix.BayesianGenerator-Tuple{NamedTuple}"><code>MarkovChainHammer.BayesianMatrix.BayesianGenerator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BayesianGenerator(parameters::NamedTuple)</code></pre><p>Construct a BayesianGenerator object from a NamedTuple of parameters.</p><p><strong>Arguments</strong></p><ul><li><code>parameters::NamedTuple</code>: A NamedTuple containing the parameters for the BayesianGenerator object. Must contain the fields <code>prior</code>, <code>posterior</code> and <code>predictive</code>, each of which must be a NamedTuple containing the parameters for the respective distributions.</li></ul><p><strong>Returns</strong></p><ul><li><code>BayesianGenerator</code>: A BayesianGenerator object constructed from the parameters. Contains the posterior distributions for the rates and exit probabilities, as well as the predictive distributions for the holding times and exit counts.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/BayesianMatrix/constructors.jl#L193-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.BayesianMatrix.BayesianGenerator-Tuple{Vector{Vector{Int64}}, GeneratorParameterDistributions}" href="#MarkovChainHammer.BayesianMatrix.BayesianGenerator-Tuple{Vector{Vector{Int64}}, GeneratorParameterDistributions}"><code>MarkovChainHammer.BayesianMatrix.BayesianGenerator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BayesianGenerator(data::Vector{Vector{Int64}}, prior::GeneratorParameterDistributions; dt=1)

The ensemble version of the BayesianGenerator constructor. Here the data is a vector of vectors of integers, where each vector of integers is a single ensemble member trajectory.

# Arguments
- `data::Vector{Vector{Int64}}`: The data to construct the BayesianGenerator object from.
- `prior::GeneratorParameterDistributions`: The prior distribution for the BayesianGenerator object.

# Keyword Arguments
- `dt::Number=1`: The time step between each data point.

# Returns
- `BayesianGenerator`: A BayesianGenerator object constructed from the data and the prior distribution. Contains the posterior distributions for the rates and exit probabilities, as well as the predictive distributions for the holding times and exit counts.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/BayesianMatrix/constructors.jl#L166-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.BayesianMatrix.GeneratorParameterDistributions-Tuple{Int64}" href="#MarkovChainHammer.BayesianMatrix.GeneratorParameterDistributions-Tuple{Int64}"><code>MarkovChainHammer.BayesianMatrix.GeneratorParameterDistributions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GeneratorParameterDistributions(number_of_states::Int; α=1, β=1, αs=ones(number_of_states - 1))</code></pre><p>Construct a GeneratorParameterDistributions object with Gamma(α, 1/β) prior distributions for the rates and Dirichlet(αs) prior distributions for the exit probabilities. Each state has the same probability distribution This is useful for construction prior distributions quickly. The underlying assumption for default rates is that the units of time are 1, and thus the rates are all by default 1. Futhermore the mean probability of each state is  1/(number<em>of</em>states-1)</p><p>The reason why the αs is of length(number<em>of</em>states - 1) is because they are exit probabilities, and hence the probability of returning to the same state is 0. The index ordering for the exit probability of state i, is [1:i-1..., i+1:number<em>of</em>states...].  For example, if number<em>of</em>states = 3, then the index ordering for state 1 is indices = [2, 3], i.e., indices[1] = 2 and indices[2] = 3, meaning, the first index corresponds to exiting through state 2 and the second index corresponds to exiting through state 3. The index ordering for state 2 is indices = [1, 3], i.e., indices[1] = 1 and indices[2] = 3, meaning, the first index corresponds to exiting through state 1 and the second index corresponds to exiting through state 3. The index ordering for state 3 is indices = [1, 2], i.e., indices[1] = 1 and indices[2] = 2, meaning, the first index corresponds to exiting through state 1 and the second index corresponds to exiting through state 2.</p><p><strong>Arguments</strong></p><ul><li><code>number_of_states::Int</code>: The number of states in the Markov chain.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>α::Number=2</code>: The shape parameter for the Gamma prior distribution for the rates.</li><li><code>β::Number=2</code>: The rate parameter for the Gamma prior distribution for the rates.</li><li><code>αs::Vector{Number}=ones(number_of_states - 1)</code>: The concentration parameters for the Dirichlet prior distribution for the exit probabilities.</li></ul><p><strong>Returns</strong></p><ul><li><code>GeneratorParameterDistributions</code>: A GeneratorParameterDistributions object with Gamma(α, 1/β) prior distributions for the rates and Dirichlet(αs) prior distributions for the exit probabilities.</li></ul><p><strong>Note on the Gamma prior distribution (from https://en.wikipedia.org/wiki/Gamma_distribution)</strong></p><p>The Gamma distribution is a conjugate prior distribution for the exponential family distribution of the rates. The Gamma distribution is parameterized by the shape parameter α and the rate parameter β. The mean of the Gamma distribution is α/β and the variance is α/β^2.</p><p><strong>Note on the Dirichlet prior distribution (from https://en.wikipedia.org/wiki/Dirichlet_distribution)</strong></p><p>The Dirichlet prior distribution is a conjugate prior distribution for the multinomial distribution of the exit probabilities. The Dirichlet prior distribution is parameterized by the concentration parameters αs.  The mean of the Dirichlet distribution is E[X⃗] = αs/sum(αs)  The covariance is CoVar[X⃗ ⊗ X⃗] = Diagonal(α̃) - α̃ ⊗ α̃ / (α₀ + 1) where α̃ = αs / α₀  and α₀ = sum(αs). The variance Var(Xᵢ) = α̃ᵢ(1-α̃ᵢ) / (α₀ + 1) where α₀ = sum(αs).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/BayesianMatrix/constructors.jl#L13-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.BayesianMatrix.uninformative_prior-Tuple{Any}" href="#MarkovChainHammer.BayesianMatrix.uninformative_prior-Tuple{Any}"><code>MarkovChainHammer.BayesianMatrix.uninformative_prior</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">uninformative_prior(number_of_states; scale=eps(1e2))</code></pre><p>Construct an uninformative prior distribution for a BayesianGenerator object.</p><p><strong>Arguments</strong></p><ul><li><code>number_of_states::Int</code>: The number of states in the BayesianGenerator object.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>scale::Number=eps(1e2)</code>: The scale parameter for the Gamma and Dirichlet distributions.</li></ul><p><strong>Returns</strong></p><ul><li><code>GeneratorParameterDistributions</code>: An uninformative prior distribution for a BayesianGenerator object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/BayesianMatrix/constructors.jl#L217-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.BayesianMatrix.unpack-Tuple{BayesianGenerator}" href="#MarkovChainHammer.BayesianMatrix.unpack-Tuple{BayesianGenerator}"><code>MarkovChainHammer.BayesianMatrix.unpack</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unpack(Q::BayesianGenerator)</code></pre><p>Unpack a BayesianGenerator object into its parameters.</p><p><strong>Arguments</strong></p><ul><li><code>Q::BayesianGenerator</code>: The BayesianGenerator object to unpack.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{NamedTuple{(:prior, :posterior, :predictive),Tuple{NamedTuple{(:α, :β, :αs),Tuple{Vector{Float64},Vector{Float64},Vector{Float64}}},NamedTuple{(:α, :β, :αs),Tuple{Vector{Float64},Vector{Float64},Vector{Float64}}},NamedTuple{(:μ, :σ, :ξ, :n, :αs),Tuple{Vector{Float64},Vector{Float64},Vector{Float64},Vector{Int64},Vector{Vector{Float64}}}}}}}</code>: A tuple containing the parameters for the prior, posterior and predictive distributions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/BayesianMatrix/constructors.jl#L235-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.Trajectory.ContinuousTimeEmpiricalProcess-Tuple{Any}" href="#MarkovChainHammer.Trajectory.ContinuousTimeEmpiricalProcess-Tuple{Any}"><code>MarkovChainHammer.Trajectory.ContinuousTimeEmpiricalProcess</code></a> — <span class="docstring-category">Method</span></header><section><div><p>ContinuousTimeEmpiricalProcess(markov<em>chain; number</em>of<em>states=length(union(markov</em>chain)))</p><p>Construct a continuous time empirical process from a discrete time Markov chain. The holding times are taken from the empirical distribution and the transition probabilities from the empirical transition probabilities</p><p><strong>Arguments</strong></p><ul><li><code>markov_chain::Vector{Int}</code>: The discrete time Markov chain to construct the continuous time empirical process from.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>number_of_states::Int=length(union(markov_chain))</code>: The number of states in the Markov chain.</li></ul><p><strong>Returns</strong></p><ul><li><code>ContinuousTimeEmpiricalProcess</code>: A continuous time empirical process constructed from the discrete time Markov chain.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/Trajectory/empirical_process.jl#L9-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.Trajectory.generate-NTuple{4, Any}" href="#MarkovChainHammer.Trajectory.generate-NTuple{4, Any}"><code>MarkovChainHammer.Trajectory.generate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate(Q, n; dt=1, initial_condition=rand(1:size(Q)[1]))</code></pre><p>Generate a Markov chain of length <code>n</code> with transition matrix <code>Q</code> and time step <code>dt</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Q::AbstractMatrix</code>: The transition matrix or generator of the Markov chain.</li><li><code>n::Int</code>: The length of the Markov chain.</li><li><code>dt::Real=1</code>: The time step of the Markov chain.</li><li><code>initial_condition::Int=rand(1:size(Q)[1])</code>: The initial condition of the Markov chain.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>progress::Bool=false</code>: Whether to show a progress bar.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Int}</code>: A Markov chain of length <code>n</code> generated by transition matrix <code>Q</code> and time step <code>dt</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/Trajectory/generate_timeseries.jl#L21-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.Trajectory.generate-Tuple{MarkovChainHammer.Trajectory.ContinuousTimeEmpiricalProcess, Any, Any}" href="#MarkovChainHammer.Trajectory.generate-Tuple{MarkovChainHammer.Trajectory.ContinuousTimeEmpiricalProcess, Any, Any}"><code>MarkovChainHammer.Trajectory.generate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate(process::ContinuousTimeEmpiricalProcess, n; initial_condition=rand(1:size(process.cumulative_distribution)[1]))</code></pre><p>Generate a Markov chain of length <code>n</code> with continuous time empirical process <code>process</code>.</p><p><strong>Arguments</strong></p><ul><li><code>process::ContinuousTimeEmpiricalProcess</code>: The continuous time empirical process to generate a Markov chain from.</li><li><code>n::Int</code>: Number of jumps to generate. i.e. lower bound to length of markov chain </li><li><code>initial_condition::Int=rand(1:size(process.cumulative_distribution)[1])</code>: The initial condition of the Markov chain.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>progress::Bool=false</code>: Whether to show a progress bar.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Int}</code>: A Markov chain of generated by a continuous time empirical <code>process</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/Trajectory/generate_timeseries.jl#L61-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.Clustering.leicht_newman-Tuple{Any}" href="#MarkovChainHammer.Clustering.leicht_newman-Tuple{Any}"><code>MarkovChainHammer.Clustering.leicht_newman</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>leicht_newman(A; modularity_type = :giorgini)</code></p><p><strong>Description</strong></p><pre><code class="nohighlight hljs">Compute the communities of a graph using the Leicht Newman algorithm.</code></pre><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray</code>: Adjacency matrix of the graph.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>modularity_type::Symbol</code>: Type of modularity matrix to use. Can be <code>:giorgini</code>, <code>:modularity</code>, <code>:generator_fine</code>, or <code>:generator_coarse</code>. Defaults to <code>:modularity</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray</code>: Array of communities.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/Clustering/spectral_clustering.jl#L70-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.Utils.autocovariance-Tuple{Any, LinearAlgebra.Eigen, Any}" href="#MarkovChainHammer.Utils.autocovariance-Tuple{Any, LinearAlgebra.Eigen, Any}"><code>MarkovChainHammer.Utils.autocovariance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autocovariance(g⃗, Q::Eigen, timelist; progress=false)</code></pre><p>Calculate the autocovariance of observable g⃗ with generator matrix Q and times at timelist. </p><p><strong>Arguments</strong></p><ul><li><code>g⃗::AbstractVector</code>: observable</li><li><code>Q::Eigen</code>: eigenvalue decomposition of generator matrix</li><li><code>timelist::AbstractVector</code>: times at which to calculate autocovariance</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>progress::Bool=false</code>: show a progress bar</li></ul><p><strong>Returns</strong></p><ul><li><code>autocov::Vector</code>: autocovariance of observable g⃗ with generator matrix Q and times at timelist</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/Utils/statistics.jl#L106-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.Utils.autocovariance-Tuple{Any, Vector{Matrix{Float64}}, Int64}" href="#MarkovChainHammer.Utils.autocovariance-Tuple{Any, Vector{Matrix{Float64}}, Int64}"><code>MarkovChainHammer.Utils.autocovariance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autocovariance(g⃗, Ps::Vector{Matrix{Float64}}, steps::Int; progress = false)</code></pre><p>Calculate the autocovariance of observable g⃗ with transition matrices Ps and number of steps.</p><p><strong>Arguments</strong></p><ul><li><code>g⃗::AbstractVector</code>: observable</li><li><code>Ps::Vector{Matrix{Float64}}</code>: transition matrices</li><li><code>steps::Int</code>: number of steps</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>progress::Bool=false</code>: show a progress bar</li></ul><p><strong>Returns</strong></p><ul><li><code>autocov::Vector</code>: autocovariance of observable g⃗ with transition matrices Ps and number of steps</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/Utils/statistics.jl#L140-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.Utils.autocovariance-Tuple{Any}" href="#MarkovChainHammer.Utils.autocovariance-Tuple{Any}"><code>MarkovChainHammer.Utils.autocovariance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autocovariance(x; timesteps=length(x), progress = false)</code></pre><p>Calculate the autocovariance of a timeseries <code>x</code> with <code>timesteps</code> lags.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector</code>: timeseries</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>timesteps::Int</code>: number of lags</li><li><code>progress::Bool</code>: show a progress bar</li></ul><p><strong>Returns</strong></p><ul><li><code>autocov::Vector</code>: autocovariance of <code>x</code> with <code>timesteps</code> lags</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/Utils/statistics.jl#L81-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.Utils.decorrelation_times-Tuple{Any}" href="#MarkovChainHammer.Utils.decorrelation_times-Tuple{Any}"><code>MarkovChainHammer.Utils.decorrelation_times</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>decorrelation_times(Q)</code></p><p><strong>Description</strong></p><pre><code class="nohighlight hljs">Calculate the decorrelation times of a generator matrix.</code></pre><p><strong>Arguments</strong></p><ul><li><code>Q::Matrix</code>: The generator matrix or transition matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>decorrelation_times::Vector</code>: The decorrelation times of the generator matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/Utils/statistics.jl#L64-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.Utils.histogram-Tuple{Any}" href="#MarkovChainHammer.Utils.histogram-Tuple{Any}"><code>MarkovChainHammer.Utils.histogram</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">histogram(array, bins=minimum([100, length(array)]), normalization=:uniform, custom_range=false)</code></pre><p><strong>Description</strong></p><pre><code class="nohighlight hljs">Compute the histogram of an array. Useful for barplot in GLMakie.</code></pre><p><strong>Arguments</strong></p><ul><li><code>array::AbstractArray</code>: Array to compute the histogram of.</li><li><code>bins::Integer</code>: Number of bins to use.</li><li><code>normalization::AbstractArray</code>: Normalization to use. If <code>:uniform</code>, then the normalization is uniform.</li><li><code>custom_range::Tuple</code>: Custom range to use. If <code>false</code>, then the range is computed from the data.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{AbstractArray, AbstractArray}</code>: Tuple of the bin centers and the histogram values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/Utils/histogram.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.Utils.koopman_modes-Tuple{Any}" href="#MarkovChainHammer.Utils.koopman_modes-Tuple{Any}"><code>MarkovChainHammer.Utils.koopman_modes</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>koopman_modes(Q)</code></p><p><strong>Description</strong></p><pre><code class="nohighlight hljs">Calculate the koopman modes of a generator matrix.</code></pre><p><strong>Arguments</strong></p><ul><li><code>Q::Matrix</code>: The generator matrix or transition matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>V⁻¹::Matrix</code>: The koopman modes of the generator matrix. Each row is a koopman mode</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/Utils/statistics.jl#L46-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.Utils.scaled_entropy-Tuple{Any}" href="#MarkovChainHammer.Utils.scaled_entropy-Tuple{Any}"><code>MarkovChainHammer.Utils.scaled_entropy</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>scaled_entropy(p)</code></p><p><strong>Description</strong></p><pre><code class="nohighlight hljs">Calculate the scaled_entropy of a probability distribution. Normalizethe entropy of the empirical distribution to that of the uniform distribution.</code></pre><p><strong>Arguments</strong></p><ul><li><code>p::Vector</code>: The probability distribution.</li></ul><p><strong>Returns</strong></p><ul><li><code>entropy_value::Real</code>: The entropy of the probability distribution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/Utils/statistics.jl#L23-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkovChainHammer.Utils.steady_state-Tuple{Any}" href="#MarkovChainHammer.Utils.steady_state-Tuple{Any}"><code>MarkovChainHammer.Utils.steady_state</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>steady_state(Q)</code></p><p><strong>Description</strong></p><pre><code class="nohighlight hljs">Calculate the steady state of a generator matrix.</code></pre><p><strong>Arguments</strong></p><ul><li><code>Q::Matrix</code>: The generator matrix or transition matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>p::Vector</code>: The steady state of the generator matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sandreza/MarkovChainHammer.jl/blob/b2288d611dc8fb40a1b27db44103b743e69c0677/src/Utils/statistics.jl#L6-L17">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Modules/utils/">« Utils</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 4 September 2023 18:07">Monday 4 September 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
